import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import calendar
import sqlite3
import mplcursors
import seaborn as sns
from matplotlib.colors import to_rgba
import tkinter as tk
import tkinter as ttk
from tkinter import scrolledtext
from PIL import Image, ImageTk
import requests
from io import BytesIO
from functools import partial
import concurrent.futures
import time
import traceback
import logging
import threading
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import LabelEncoder

#? One issue with this is how to identify the unique ids,
#? -- title would work but issue is that titles may be different at some points, missing a word, title was cut off, etc
#? -- by picture, find a software to identify the image by picutre, but wouldn't be as accurate as well, maybe
#? can do some experimenting with this to figure out how to identify this
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
class StatsVisualizer:
    """
    turns statistics into visualizations, regardless of whether stats are for depop, grailed, ebay, etc
    """
    #! change dp_account_username to just the signin username, so that its general and dynamic if the name were to change
    def __init__(self, database_path, depop_username, time_slot, time_frame, time_year, graph_descriptor, graph_agg, graph_program):
        self.root = tk.Tk()
        self.frame = tk.Frame(tk.Toplevel(self.root))
        self.frame.grid()

        self.pie_chart = None
        self.fig = None
        self.ax = None
        self.pie_fig = None
        self.pie_ax = None
        # self.pie_fig = None
        # self.pie_ax = None
        self.scrollbar = None
        self.text_area = None
        self.annotation = None

        self.selected_value = None
        self.selected_program_value = None
        self.selected_agg_value = None
        self.selected_graph_value = None
        self.selected_descriptor_value = None
        self.selected_time_value = None

        self.dropdown_menu_one = None
        self.dropdown_menu_two = None
        self.dropdown_agg_menu = None
        self.dropdown_graph_menu = None

        self.time_value = None
        self.current_time_label = None
        self.new_time_label = None

        self.graph_label = None
        self.current_graph_label = None
        self.new_graph_label = None

        self.descriptor_label = None
        self.current_descriptor_label = None
        self.new_descriptor_label = None

        self.agg_label = None
        self.current_agg_label = None
        self.new_agg_label = None

        self.current_label = None
        self.new_label = None
        self.label = None

        self.current_program_label = None
        self.new_program_label = None
        self.label_two = None

        self.database_path = database_path

        self.bars = None
        self.database_in_use = None
        self.database_we_are_using = None
        self.conn = sqlite3.connect(self.database_path)
        self.cursor = self.conn.cursor()
        self.depop_username = depop_username
        self.dp_csv_solds_table = f'dp_csv_solds_{self.depop_username}'
        self.dp_ui_table = f'dp_sold_{self.depop_username}'
        self.db = pd.read_sql(f'SELECT * FROM  overall_solds_{self.depop_username}', con=self.conn)
        self.arrow_button_frame = None
        self.current_graph_in_use = None

        self.arrow_left_image = Image.open(r"/Users/argelarroyo/Downloads/leftarrow.png")
        self.arrow_left_image = ImageTk.PhotoImage(self.arrow_left_image)
        self.arrow_right_image = Image.open(r"/Users/argelarroyo/Downloads/rightarrow.png")
        self.arrow_right_image = ImageTk.PhotoImage(self.arrow_right_image)

        self.overall_solds_label = None
        self.overall_revenue_label = None
        self.total_num_of_solds = 0.0
        self.total_revenue = 0

        self.graph_agg = graph_agg
        self.graph_descriptor = graph_descriptor
        self.time_slot = time_slot
        self.time_frame = time_frame
        self.time_year = time_year
        self.graph_program = graph_program

        self.get_image_list = None
        self.actual_images_list = None

        self.program_total_name_list = None
        self.db['date'] = pd.to_datetime(self.db['Date of sale'])
        self.db['day'] = self.db['date'].dt.day
        self.db['week'] = self.db['date'].dt.isocalendar().week
        self.db['month'] = self.db['date'].dt.month
        self.db['quarter'] = self.db['date'].dt.quarter
        self.db['year'] = self.db['date'].dt.year
        self.db['time_to_sale'] = pd.to_datetime(self.db['Date of sale']) - pd.to_datetime(self.db['Date of listing'])
        self.db['num_of_days'] = self.db['time_to_sale'].dt.days
        self.date_dictionary = {
            'week': self.db['date'].dt.isocalendar().week,
            'month': self.db['date'].dt.month,
            'quarter': self.db['date'].dt.quarter,
            'year': self.db['date'].dt.year
        }
        self.db['Date of sale'] = pd.to_datetime(self.db['Date of sale'], format='%m/%d/%Y')

        #would have to do this to every platform? maybe just create a for loop like depop_min_row depop_max_row, grailed_min_row, grailed_max_row, etc
        #its important to prepare grailed data too, since depop and grailed are a lot more similar then ebay and depop
        self.min_date = self.db['Date of sale'].min()
        self.max_date = self.db['Date of sale'].max()
        min_row = self.db.loc[self.db['Date of sale'] == self.min_date]
        max_row = self.db.loc[self.db['Date of sale'] == self.max_date]

        # Extract values from the 'quarter', 'month', 'year', and 'week' columns
        self.min_week = min_row['week'].values[0]
        self.min_month = min_row['month'].values[0]
        self.min_quarter = min_row['quarter'].values[0]
        self.min_year = min_row['year'].values[0]

        self.max_week = max_row['week'].values[0]
        self.max_month = max_row['month'].values[0]
        self.max_quarter = max_row['quarter'].values[0]
        self.max_year = max_row['year'].values[0]

        self.image_url_counter = None
        self.iteration_counter = None

    #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

    #! so far the issue with this is that im not sure if the concat tables method is needed, as long as DepopProgramsCSV Scraper is able to scrape everything properly
    # def concat_depop_data(self):
    #     """ 
    #     Concats the two depop databases together
    #     - One from csv
    #     - One from UI Scraping
    #     #! to get more info about 1 profiles sales
    #     """
    #     try:
    #         self.cursor.execute(
    #             f"""
    #                 DROP TABLE dp_overall_solds
    #             """
    #         )
    #         self.conn.commit()
    #     except:
    #         print('NO TABLE TO REMOVE')
    #      #! STEP 1
    #      #? Figure out the proper columns you will need for the universal, even if they both dont have it, you can enter an N/A value for the whole column depending on program, since this will help gather all information into one
    #      #?column where i can then use a where clause to filter by program
    #     self.cursor.execute(
    #         f"""
    #             CREATE TABLE dp_overall_solds_{self.depop_username} AS
    #             SELECT {self.dp_csv_solds_table}.*, {self.dp_ui_table}.dp_condition AS Condition, {self.dp_ui_table}.dp_men_or_wmn AS Gender, {self.dp_ui_table}.dp_likes AS Likes, {self.dp_ui_table}.dp_gen_category AS General_Category, {self.dp_ui_table}.dp_category AS Category,  {self.dp_ui_table}.dp_color1 AS Color, {self.dp_ui_table}.dp_images AS Images, {self.dp_ui_table}.dp_image_len AS Images_Length, {self.dp_ui_table}.dp_url_list AS Item_URL
    #             FROM {self.dp_csv_solds_table}
    #             LEFT JOIN {self.dp_ui_table}
    #             ON {self.dp_csv_solds_table}.Description = {self.dp_ui_table}.dp_title;
    #         """
    #     )

    # def concat_all_data(self):
    #     """ 
    #     Once we have depop data fully scraped, we then can use this to combine...
    #     Concatted depop data
    #     ebay data
        
    #     to get one general database
    #     """
    #     #! identify if concat database is available or not
    #     try:
    #         self.cursor.execute(
    #             f"""
    #                 DROP TABLE overall_solds_{self.depop_username}
    #             """
    #         )
    #     except Exception as e:
    #         print(e)
    #         print('NO TABLE TO REMOVE')
        
    #     #this concat table should be good now as long as the tables are all correct, but all values should be unionable
    #     #! now need to figure out what to do next once i have this combined table of all my statistics
    #     #TODO Create a graph for this?
    #     #TODO create the dictionary for Category/ ebay_type
    #     self.cursor.execute(
    #         f"""
    #             CREATE TABLE overall_solds_{self.depop_username} AS
    #             SELECT "Date of sale", "Date of listing", Description, "Total after fees", Likes, Condition, Gender, Category, Brand, Color, Size, Images, Images_length, Item_URL, "Depop" AS Program FROM dp_overall_solds_{self.depop_username}
    #             UNION
    #             SELECT ebay_sale_date, ebay_start_date, ebay_title, ebay_price, "0" AS ebay_likes, ebay_condition, ebay_department, ebay_type, ebay_brand, ebay_color, ebay_size, ebay_images, ebay_images_len, ebay_item_link, 'Ebay' AS program FROM ebay_sold_{self.depop_username}
    #         """
    #     )
    #     self.conn.commit()

        #! if moves to except, than this signifies that this table needs to be concatted
        #! from depop page, need
        #! General_Category #? For general category, just creeate a dictionary for all types of clothing

        #TODO ebay_type might needs a dictionary,
        #TODO ebay_size needs work done on it to get all the sizes, size missing for some rows
        #TODO Find sizes for hats, just create size list and check title to see if any word in title is in list
        #TODO can maybe do the same thing for brand? already have something similar to that
        #TODO Remove all text in the database that state **ANONYMIZED_... ***, since no information in that will be able to help me really
        #? Actually find out why its anonimized, because the only thing anonymized is the description, name adn the title but i still get all the
        #? Actually the only information i get from this is the category, the total, the size and the brand but thats still enough for me

    #!!!!!!!!!!!!!!!!!!!!!!!!#!!!!!!!!!!!!!!!!!!!!!!!!#!!!!!!!!!!!!!!!!!!!!!!!!#!!!!!!!!!!!!!!!!!!!!!!!!#!!!!!!!!!!!!!!!!!!!!!!!!
    #! common functions that are used within this program
    def delete_text_area(self):
        """
        This checks if the text area is already created, and if it is, it deletes it
        """
        try:
            self.text_area.delete(1.0, tk.END)
        except:
            pass
 #!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #! the methods we use to gather or transform information into something more organized for the program
    def month_name(self, time_num):
        """
        this is a function we can use to return the proper month in word form, for our use in visualizing
        """
        return calendar.month_name[time_num]

    def value_to_color(self, value, cmap='Greens', lower_bound=.2, upper_bound=1):
        """
        conoverts the color on the bar based on teh value that is being plotted
        """
        norm_value = value / max_value  # Normalize the value
        adjusted_norm_value = lower_bound + (upper_bound - lower_bound) * norm_value
        rgba_color = plt.get_cmap(cmap)(adjusted_norm_value)
        return to_rgba(rgba_color)

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#! custome aggregates we have used for this
    def price_from_average(self, x):
        """
        we calculate how far or close the price is from the average, the higher above average, the more we should rate this piece,
        """
        #! find the mean of total after fees, and just find out how much above or below the number is
        mean_value = x.mean()
        # Calculate the differences from the mean without converting to integers
        differences = np.abs(x - mean_value)
        return differences

    def most_profit(self):
        """
        calculate the most profitable items, depending on just most profit in general, or most depending on the scale of what we bought the item for
        """
        #! for this I would need to create a column to find how much I payed for the item, where and how can I insert this?
        #? Just estimate an average depending on the category?
        """
            T-shirt: 3
            Pants: 6
            Hats: 2
            Shoes: 8
            Jacket: 6
        """ #!can do this for the most part, but still want an opportunity to add purchase cost personally and individually?
        #? When creating the post, add a purchase cost slot to update into the listings category
        """
        which will then create a new excel spreadsheet then from there can concat this sheet to the program scraper sheet to get more information from it
        """

        #! then just find the ratio of profit to item cost, or just how much profit, and maybe even include a function to take the time to sell into consideration

    def get_image(self, source, image):
        """
        gets image from either file or url and inserts image into text_file scroll bar we created
        allowing us to see the image and see the description for it
        """
        if source == 'file':
            img = Image.open(image)
        elif source == 'url':
            response = requests.get(image)
            img = Image.open(BytesIO(response.content))
        img = img.resize((120, 120), Image.BILINEAR)
        return img

    def display_image(self, image, image_num):
        """ 
        Obtain image info from get_image() method and then place the image into the text area.
        """
        image_tk = ImageTk.PhotoImage(image)
        label = tk.Label(self.text_area.master, image=image_tk)
        label.image = image_tk
        row_num = (image_num * 16)
        position = f'{row_num}.0'
        self.text_area.insert(position, '\n')
        self.text_area.image_create(position, image=image_tk)
        self.text_area.insert(position, '\n')

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#! ways that we can create graphs for this project and by what style, depending on the type of graphs that is chosen
    def graph_date_creator(self, descriptor_value_to_filter=None, first=True): #!!!!!!
        """
        #! this method will only be to sort where x values are descriptors
        essentially is the the COUNT(*)
        only graphs based on date, so graphs all time date for the most part, or will break up to do within quarters or somethiing and years if i want to get fancy
        """
        column_title = f'year_{self.time_frame}'
        x_label = f'Year and {self.time_frame.title()}s'
        y_label = 'Total Sales Count'
        self.graph_agg = 'mean'
        self.current_graph_in_use = 'Graphing by Date'

        agg_for_title = 'Count' if self.graph_agg == 'size' else self.graph_agg

        #? What exactly does this do? Explain
        #! This edits the title to add which descriptor is being filtered and below that shows us how we are filtering it by, whether its..
        """ 
        - by category
        - by brand
        - by specific category/brand, etc
        """ #! i mention only category and brand just cause those will be the main columns we filter by
        if descriptor_value_to_filter is not None:
            item_title = f'Total {agg_for_title.title()} of {descriptor_value_to_filter} per {self.time_frame.title()}'
        else:
            item_title = f'Total {agg_for_title.title()} per {self.time_frame.title()}'
        pd.set_option('display.max_columns', None)
        # sales_by_time_slot = self.db[self.db[descriptor] == descriptor_value_to_filter] #! this code we will work on later, in terms of creating it in the title too, this will just help us look at a specific element and analyze that one element alone
        #! to track sales better, and more in depth
        og_sales_by_time_slot = self.db
        sales_to_edit = self.db
        sales_to_edit = self.filtering_program(sales_to_edit)
        sales_by_time_slot = self.sales_agg_method(sales_to_edit, True)
        if self.time_frame == 'month': #! column title would be the dates that we organize for our x values
            sales_by_time_slot[column_title] = sales_by_time_slot['year'].astype(str) + '-' + sales_by_time_slot[self.time_frame].astype(str)
            sales_by_time_slot[column_title] = sales_by_time_slot[column_title].apply(lambda x: f"{calendar.month_name[int(x.split('-')[1])]} {x.split('-')[0]}")
            og_sales_by_time_slot[column_title] = og_sales_by_time_slot['year'].astype(str) + '-' + og_sales_by_time_slot[self.time_frame].astype(str)
            og_sales_by_time_slot[column_title] = og_sales_by_time_slot[column_title].apply(lambda x: f"{calendar.month_name[int(x.split('-')[1])]} {x.split('-')[0]}")
        elif self.time_frame in ['day', 'quarter', 'week', 'year']:
            sales_by_time_slot[column_title] = sales_by_time_slot['year'].astype(str) + '-' + sales_by_time_slot[self.time_frame].astype(str)
            sales_by_time_slot[column_title] = sales_by_time_slot[column_title].apply(lambda x: f"{self.time_frame.title()} {x.split('-')[1]} of {x.split('-')[0]}")
            og_sales_by_time_slot[column_title] = og_sales_by_time_slot['year'].astype(str) + '-' + og_sales_by_time_slot[self.time_frame].astype(str)
            og_sales_by_time_slot[column_title] = og_sales_by_time_slot[column_title].apply(lambda x: f"{self.time_frame.title()} {x.split('-')[1]} of {x.split('-')[0]}")
        self.graph_adjustors(x_label, y_label, item_title, sales_by_time_slot[column_title], sales_by_time_slot[f'sales_for_{self.graph_agg}'], sales_by_time_slot, self.graph_descriptor, 'date', first, og_sales_by_time_slot)

    def graphing(self, first=True): #!!!!!!!
        """ 
        method we will use to find the information that we need to graph,
        #! working on making this dynamic to be able to just fully use arguments and whatnot
        """
        #TODO WHAT TO DO TO UPDATE THIS TO BE SIMLIAR WITH graph_date_creator
        """ 
        add aggregates to dictionary to put in hover
        """
        self.current_graph_in_use = 'Graphing by Descriptor'
        x_label = f'Year and {self.time_frame.title()}s'
        y_label = 'Total Sales Count'
        agg_for_title = 'Count' if self.graph_agg == 'size' else self.graph_agg
        if self.graph_descriptor == 'Total after fees':
            descriptor_for_title = 'Price'
        else:
            descriptor_for_title = self.graph_descriptor

        if self.time_slot == 'all':
            item_title = f'Total {agg_for_title.title()} by {descriptor_for_title}'
        else:
            if self.time_frame == 'month':
                item_title = f'Total {agg_for_title.title()} by {descriptor_for_title} for {self.month_name(self.time_slot)} {self.time_year}'
            elif self.time_frame == 'year':
                item_title = f'Total {agg_for_title.title()} by {descriptor_for_title} for {self.time_year}'
            else:
                item_title = f'Total {agg_for_title.title()} by {descriptor_for_title} for {self.time_frame.title()} {self.time_slot} {self.time_year}'
        if self.time_frame in self.date_dictionary:
            if self.time_slot != 'all':
                chosen_data = self.db[(self.date_dictionary[self.time_frame] == self.time_slot) & (self.db['date'].dt.year == self.time_year)].copy()
            else:
                chosen_data = self.db.copy()
            #! group_by_descriptor filters by year and self.time_frame as well, but not sure when exactly those will be needed? if needed at all?
            #! just using descriptor solved the issue i had
            chosen_data = self.filtering_program(chosen_data)
            chosen_sales = self.sales_agg_method(chosen_data)
            chosen_sales = chosen_sales.sort_values(by=f'sales_for_{self.graph_agg}', ascending=False)
            pd.set_option('display.max_columns', None)
        self.graph_adjustors(x_label, y_label, item_title, chosen_sales[self.graph_descriptor], chosen_sales[f'sales_for_{self.graph_agg}'], chosen_sales, self.graph_descriptor, 'descriptor', first, chosen_data)

    def average_time_to_sell(self, first=True):
        """
        calculates average time to sell something based on given descriptor(s)
        """
        self.current_graph_in_use = 'Average Time to Sell'
        x_label = 'Days to Sell'
        y_label = 'Quantity Sold'
        if self.time_frame == 'month':
            timeline_text = f'{self.month_name(self.time_slot)} {self.time_year}'
        else:
            timeline_text = f'{self.time_frame.title()} {str(self.time_slot)} {self.time_year}'
        if self.time_frame in self.date_dictionary:
            quick_sale_data = self.db[(self.date_dictionary[self.time_frame] == self.time_slot) & (self.date_dictionary['year'] == self.time_year)].copy()
            average_time_of_sale = quick_sale_data.groupby([self.graph_descriptor, self.time_frame])['time_to_sale'].mean().reset_index()
            average_time_of_sale = average_time_of_sale.sort_values(by=[self.time_frame, 'time_to_sale'], ascending=False)
            quick_sale_data = self.filtering_program(quick_sale_data)
            sales_agg = ['mean', 'sum', 'size', 'max']
            for sale in sales_agg:
                desired_sales = quick_sale_data.groupby(self.graph_descriptor)['Total after fees'].agg(sale).round(2).reset_index(name=f'sales_for_{sale}')
                average_time_of_sale[f'sales_for_{sale}'] = desired_sales[f'sales_for_{sale}']

            self.graph_adjustors(x_label, y_label, timeline_text, average_time_of_sale[self.graph_descriptor], average_time_of_sale['time_to_sale'].dt.days, average_time_of_sale, self.graph_descriptor, 'descriptor', first, quick_sale_data)

    def quickest_sales(self, first=True, sold_time=100):
        """
        analyzes which sells the quickest, in less than 30 days, which brands, or whatever category, does the best
        """
        #! currently si the self.db['time_to_sale].dt.days < sold_time that is messing up for some reason
        #! with the other conditionals it works perfectly, but with this one thing it only works after the first one for some reason,
        x_label = 'Quickest solds'
        y_label = 'Descriptors'
        self.current_graph_in_use = 'Quickest Sales'
        if self.time_frame != 'all':
            sold_within_time = self.db[(self.db['num_of_days'] < sold_time) & (self.db[self.time_frame] == self.time_slot) & (self.db['year'] == self.time_year)].copy()
            if self.time_frame == 'month':
                timeline_text = f'Quickest Sales for {self.month_name(self.time_slot)} {self.time_year}'
            else:
                timeline_text = f'Quickest Sales for {self.time_frame.capitalize()} {str(self.time_slot)} {self.time_year}: Sold Within {sold_time} days'
        elif self.time_frame == 'all':
            sold_within_time = self.db[(self.db['num_of_days'] < sold_time) & (self.db[self.graph_descriptor] is not None)]
            timeline_text = 'Total'
        items_sold_within_time = sold_within_time[self.graph_descriptor].value_counts().reset_index()
        sales_agg = ['mean', 'sum', 'size', 'max']
        sold_within_time = self.filtering_program(sold_within_time)
        for sale in sales_agg:
            desired_sales = sold_within_time.groupby(self.graph_descriptor)['Total after fees'].agg(sale).round(2).reset_index(name=f'sales_for_{sale}')
            items_sold_within_time[f'sales_for_{sale}'] = desired_sales[f'sales_for_{sale}']
        items_sold_within_time = items_sold_within_time.sort_values(by='sales_for_size', ascending=False)
        self.graph_adjustors(x_label, y_label, timeline_text, items_sold_within_time[self.graph_descriptor], items_sold_within_time['sales_for_size'], items_sold_within_time, self.graph_descriptor, 'descriptor', first, sold_within_time)

    def filtering_program(self, database):
        if self.graph_program != 'All':
            database_we_are_given = database[database['Program'] == self.graph_program]
        else:
            database_we_are_given = database
        return database_we_are_given

    def sklearn_model(self):
        try:
            print('oops')
        except:
            """  
            Where we will create out dynamic machine learning model
            #! 
            """
            #! still very much a work in progress and not a priority at the moment
            df = pd.DataFrame({descriptor: items_sold_within_time.index, 'sales_quantity': items_sold_within_time.values})

            # Use pd.get_dummies to one-hot encode the 'descriptor' column
            label_encoder = LabelEncoder()
            df[descriptor] = label_encoder.fit_transform(df[descriptor])

            X = df.drop('sales_quantity', axis=1).values
            y = df['sales_quantity'].values
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
            
            model = LinearRegression()
            model.fit(X_train, y_train)
            y_pred = model.predict(X_test)
            mse = mean_squared_error(y_test, y_pred)
            plt.scatter(X_test, y_test, color='black', label='Actual values')
            plt.scatter(X_test, y_pred, color='blue', label='Predicted values')
            plt.title('Actual vs Predicted values')
            plt.xlabel('Features')
            plt.ylabel('Sales Quantity')
            # plt.legend()
            plt.show()
            # X = 
            # y = 
            # X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

    def sales_agg_method(self, chosen_data, graph_date=False):
        #! need to get this working for other 2 functions, quickest_sales & average_time_to_sell
        if graph_date == True:
            group_by_variable = ['year', self.time_frame]
            if self.time_frame == 'year':
                group_by_variable = ['year']
        else:
            group_by_variable = self.graph_descriptor
        sales_agg = ['mean', 'sum', 'size', 'max']
        #! this is to ensure that our chosen agg is created first, so we can use this to create our graph
        chosen_sales = chosen_data.groupby(group_by_variable)['Total after fees'].agg(self.graph_agg).round(2).reset_index(name=f'sales_for_{self.graph_agg}')
        for sale in sales_agg:
            if self.graph_agg != sale:
                #! these aggs are done to place into the hover element
                desired_sales = chosen_data.groupby(group_by_variable)['Total after fees'].agg(sale).round(2).reset_index(name=f'sales_for_{sale}')
                chosen_sales[f'sales_for_{sale}'] = desired_sales[f'sales_for_{sale}']

        desired_time_sales = chosen_data.groupby(group_by_variable)['num_of_days'].agg('mean').round(0).reset_index(name=f'time_sales_for_avg')
        chosen_sales['time_sales_for_avg'] = desired_time_sales['time_sales_for_avg']

        self.program_total_name_list = chosen_data['Program'].unique()
        for programs in self.program_total_name_list:
            program_data = chosen_data[chosen_data['Program'] == programs]
            program_sales = program_data.groupby(group_by_variable)['Total after fees'].agg('sum').round(2).reset_index(name=f'{programs}_sales_sum')
            chosen_sales = pd.merge(chosen_sales, program_sales, how='left', left_on='Brand', right_on='Brand')
            chosen_sales.fillna(float(0), inplace=True)
        return chosen_sales

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#! where we prepare the info of the text that we put into the scrollbar text area, which rows are entered in
    def on_bar_click(self, event, descriptor_used, type_of_graph):
        #! issue where i have to click twice to get the bar to show up??
        #? figure out why for this
        """ 
        this is if we want to see the info based on a specific type of bar, we can click that bar
        and all the rows in that bar will shop up in the scroll bar text area
        """
        if event.artist in self.bars:
            index = self.bars.index(event.artist)
            _, labels = plt.xticks()
            bar_name = labels[index].get_text()
            self.iterate_through_graph_info(bar_name, descriptor_used, type_of_graph)
            self.selected_program_value.set('All')
            self.selected_value.set('Nearest Sold')
            self.threading_information_method('Nearest Sold', 'Filter')

    def iterate_through_graph_info(self, descriptor_filter, type_of_graph, descriptor_name=None):
        """ 
        gathers data that is in the graph in a list form to see each one individually
        it then uploads this into a tkinter window allowing us to see the exact post listed in that draft
        #! what other stats would be useful to see in this?
        #? how long took to sell
        #? Profit made
        #? 
        """
        #TODO need to figure out a way to display the image quick and easy, it takes too long to do normally
        if type_of_graph == 'date' or descriptor_name == 'date':
            type_of_graph = 'year_month'
        if not hasattr(self, 'scrollbar') or self.scrollbar is None:
            self.scrollbar = tk.Scrollbar(self.root)
            self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
            self.text_area = scrolledtext.ScrolledText(self.root, wrap=tk.WORD, width=220, height=60, yscrollcommand=self.scrollbar.set)
            self.text_area.pack()
            self.text_area.config(yscrollcommand=self.scrollbar.set)
            self.scrollbar.config(command=self.text_area.yview)
            self.create_arrow_button()
            self.create_text_area_filter_menu()
            self.create_program_filter_menu()
            self.create_agg_dropdown_menu()
            self.create_descriptor_dropdown()
            self.create_graph_dropdown()
            self.create_time_dropdown()
            self.create_overall_stats_dropdown()
        if descriptor_name is not None:
            self.database_we_are_using = self.database_in_use[self.database_in_use[type_of_graph] == descriptor_filter] #name must be year month
        else:
            self.database_we_are_using = self.database_in_use

        self.delete_text_area()
        self.threading_information_method('Nearest Sold', 'Filter')

    def create_text_area_filter_menu(self):
        """
        this dropdown menu we use to add our filter, how we want to filter the data in textarea scrollbar
        """
        dropdown_window_one = tk.Toplevel(self.root)
        dropdown_window_one.title("Text Area Filter")

        self.selected_value = tk.StringVar()

        options = ["Nearest Sold", "Farthest Sold", "Highest to Lowest Price", "Lowest to Highest Price",  "Sold Quickest", "Sold Longest"]

        dropdown_menu_one = tk.OptionMenu(dropdown_window_one, self.selected_value, *options)
        dropdown_menu_one.pack(padx=10, pady=10)
        self.selected_value.set(options[0])
        self.label = tk.Label(dropdown_window_one, text="")
        self.label.pack(pady=10)
        self.update_text_area_filter_label()

    def update_text_area_filter_label(self):
        """
        changes the text area based on the filter method in the dropdown that is selected
        """
        selected_option = self.selected_value.get()
        self.label.config(text=f"Selected Data Filter: {selected_option}")

        self.current_label = selected_option
        self.root.after(1000, self.update_text_area_filter_label)

        if self.current_label != self.new_label and self.new_label is not None:
            self.threading_information_method(selected_option, 'Filter')
        self.current_label = selected_option
        self.new_label = selected_option

    def create_program_filter_menu(self):
        """
        this second dropdown menu we use to by what program we want to filter out data in textarea scrollbar
        """
        dropdown_window_two = tk.Label(self.frame, text='Program')
        dropdown_window_two.grid(row=3, column=1)

        self.selected_program_value = tk.StringVar()

        program_options = ['All', 'Depop', 'Ebay', 'Grailed', 'Facebook Marketplace', 'Offer Up']

        dropdown_menu_two = tk.OptionMenu(self.frame, self.selected_program_value, *program_options)
        dropdown_menu_two.grid(row=4, column = 1)

        self.selected_program_value.set(program_options[0])

        self.label_two = tk.Label(self.frame, text="")
        self.label_two.grid(row=5, column=1)
        self.update_program_filter_label()

    def update_program_filter_label(self):
        """
        changes the text area based on the filter method in the dropdown that is selected
        """
        selected_program_value = self.selected_program_value.get()
        self.label_two.config(text="Selected Program Value: " + selected_program_value)
        self.current_program_label = selected_program_value
        self.graph_program = selected_program_value

        self.root.after(1000, self.update_program_filter_label)

        if self.current_program_label != self.new_program_label and self.new_program_label is not None:
            self.adjusting_graph('Neutral')
        self.current_program_label = selected_program_value
        self.new_program_label = selected_program_value

    def create_arrow_button(self):
        """
        #! need to create this so that
        it changes time_slot flawlessly
        """
        arrow_button_increase = tk.Button(self.frame, image=self.arrow_left_image, width=200, height=100, command=partial(self.arrow_button_clicked, "Decrease"))
        arrow_button_increase.grid(row=4, column=2)

        arrow_button_decrease = tk.Button(self.frame, image=self.arrow_right_image, width=200, height=100, command=partial(self.arrow_button_clicked, 'Increase'))
        arrow_button_decrease.grid(row=4, column=3)

    def arrow_button_clicked(self, adjusting):
        """
        All this will do is adjust the time_slot and time_year accordingly, since we will only be using those arrow buttons to adjust the time period of what our graph will be showing
        """
        time_slot_dictionary = {
            'quarter': 4,
            'month': 12,
            'week': 52
        }
        if self.time_frame in time_slot_dictionary:
            #! increasing time slot
            if adjusting == 'Increase':
                if self.time_slot == time_slot_dictionary[self.time_frame]:
                    self.time_year += 1
                    self.time_slot = 1
                else:
                    self.time_slot  += 1

            #! decreasing time slot
            if adjusting == 'Decrease':
                if self.time_slot == 1:
                    self.time_slot = time_slot_dictionary[time_frame]
                    self.time_year -= 1
                else:
                    self.time_slot -= 1
            self.adjusting_graph(adjusting)

    def adjusting_graph(self, adjusting_variable):
        """
        #! can change time periods but can I alter time periods? like from quarters to months?
        #! If I figure that out, then I can figure out how to change the descriptor and the aggregate to make it completely customizeable
        #! create way to identify which type of graph it is to make it start properly and the right one
        #! To Identify the type of graph create a variable in __init__ labeled self.current_graph = None
        #! and define that variable with each variable then just call
        #! if self.current_graph == ...:
        """

        #would have to do this to every platform? maybe just create a for loop like depop_min_row depop_max_row, grailed_min_row, grailed_max_row, etc
        #its important to prepare grailed data too, since depop and grailed are a lot more similar then ebay and depop
        #! this is good for now but need to figure out a way to isolate the overall db, just in case i want to filter by program
        # db_using = self.database_in_use
        db_using = self.db
        min_date = db_using['Date of sale'].min()
        max_date = db_using['Date of sale'].max()
        min_row = db_using.loc[db_using['Date of sale'] == min_date]
        max_row = db_using.loc[db_using['Date of sale'] == max_date]

        # Extract values from the 'quarter', 'month', 'year', and 'week' columns
        min_day = min_row['day'].values[0]
        min_week = min_row['week'].values[0]
        min_month = min_row['month'].values[0]
        min_quarter = min_row['quarter'].values[0]
        min_year = min_row['year'].values[0]

        max_day = max_row['day'].values[0]
        max_week = max_row['week'].values[0]
        max_month = max_row['month'].values[0]
        max_quarter = max_row['quarter'].values[0]
        max_year = max_row['year'].values[0]
        continue_with_graph = True
        print(continue_with_graph)
        if self.time_frame == 'day':
            if max_day == 365:
                max_year += 1
                max_day = 1
            if min_day == 1:
                min_year -= 1
                min_day = 365
        if self.time_frame == 'week':
            if max_week == 52:
                max_year += 1
                max_week = 1
            if min_week == 1:
                min_year -= 1
                min_week = 52
        elif self.time_frame == 'month':
            if max_month == 12:
                max_year += 1
                max_month = 1
            if min_month == 1:
                min_year -= 1
                min_month = 12
        elif self.time_frame == 'quarter':
            if max_quarter == 4:
                max_year += 1
                max_quarter = 1
            if min_quarter == 1:
                min_year -= 1
                min_quarter = 4

        #! need to figure out issue with month, quarter, week, when on last possible number, i need to let it go at least one more month, but in this case, it wont go to month 13, it woud have to be 1, so find some way to use remainder? and then just like increase the year by one as well?
        if adjusting_variable == 'Increase':
            counter_variable = 'Decrease'
            if (self.time_year >= max_year):
                print('year is the same year')
                if (self.time_frame == 'quarter') and (self.time_slot >= max_quarter):
                    print(f"Quarter condition met: {self.time_slot}, {max_quarter}")
                    continue_with_graph = False
                elif (self.time_frame == 'month') and (self.time_slot >= max_month):
                    print(f"Month condition met: {self.time_slot}, {max_month}")
                    continue_with_graph = False
                elif (self.time_frame == 'week') and (self.time_slot >= max_week):
                    print(f"Week condition met: {self.time_slot},{max_week}")
                    continue_with_graph = False
                elif (self.time_frame == 'day') and (self.time_slot >= max_day):
                    print(f"Day condition met: {self.time_slot}, {max_day}")
                    continue_with_graph = False

        elif adjusting_variable == 'Decrease':
            counter_variable = 'Increase'
            if (self.time_year <= min_year):
                if (self.time_frame == 'quarter') and (self.time_slot <= min_quarter):
                    print(f"Quarter condition met: {self.time_slot}, {min_quarter}")
                    continue_with_graph = False
                elif (self.time_frame == 'month') and (self.time_slot <= min_month):
                    print(f"Month condition met: {self.time_slot}, {min_month}")
                    continue_with_graph = False
                elif (self.time_frame == 'week') and (self.time_slot <= min_week):
                    print(f"Week condition met: {self.time_slot}, {min_week}")
                    continue_with_graph = False
                elif (self.time_frame == 'day') and (self.time_slot <= min_day):
                    print(f"Day condition met: {self.time_slot}, {min_day}")
                    continue_with_graph = False

        if continue_with_graph == True:
            continue_with_graph = False
            plt.clf()
            first_time = False
            if self.current_graph_in_use == 'Average Time to Sell':
                stats_instance.average_time_to_sell(first_time)
            elif self.current_graph_in_use == 'Graphing by Descriptor':
                stats_instance.graphing(first_time)
            elif self.current_graph_in_use == 'Graphing by Date':
                stats_instance.graph_date_creator(first=first_time)
            elif self.current_graph_in_use == 'Quickest Sales':
                stats_instance.quickest_sales(first_time)
        else:
            self.arrow_button_clicked(counter_variable)
            logger.info('The graph is already at its maximum or minimum, cant alter anymore')

    def create_agg_dropdown_menu(self):
        dropdown_agg_window = tk.Label(self.frame, text='Aggregate')
        dropdown_agg_window.grid(row=0, column=2)
        self.selected_agg_value = tk.StringVar()
        agg_options = ['Mean', 'Sum', 'Size', 'Max']
        dropdown_agg_menu = tk.OptionMenu(self.frame, self.selected_agg_value, *agg_options)
        dropdown_agg_menu.grid(row=1, column=2)
        self.selected_agg_value.set(self.graph_agg.title())
        self.agg_label = tk.Label(self.frame, text='Agg')
        self.agg_label.grid(row=2, column=2)
        self.update_agg_label()

    def update_agg_label(self):
        selected_agg_value = self.selected_agg_value.get()
        self.agg_label.config(text= f'Selected Aggregate: {selected_agg_value}')
        self.current_agg_label = selected_agg_value
        self.root.after(1000, self.update_agg_label)
        if self.current_agg_label != self.new_agg_label and self.new_agg_label is not None:
            self.graph_agg = selected_agg_value.lower()
            self.adjusting_graph('Neutral')
        self.current_agg_label = selected_agg_value
        self.new_agg_label = selected_agg_value

    def create_graph_dropdown(self):
        dropdown_graph_window = tk.Label(self.frame, text='Types of Graphs')
        dropdown_graph_window.grid(row=3, column=0)
        self.selected_graph_value = tk.StringVar()
        agg_options = ['Average Time to Sell', 'Graphing by Descriptor', 'Graphing by Date', 'Quickest Sales']
        dropdown_agg_menu = tk.OptionMenu(self.frame, self.selected_graph_value, *agg_options)
        dropdown_agg_menu.grid(row=4, column=0)
        self.selected_graph_value.set(self.current_graph_in_use.title())
        self.graph_label = tk.Label(self.frame, text='Agg')
        self.graph_label.grid(row=5, column=0)
        self.update_graph_label()

    def update_graph_label(self):
        selected_graph_value = self.selected_graph_value.get()
        self.graph_label.config(text= f'Selected Aggregate: {selected_graph_value}')
        self.current_graph_label = selected_graph_value
        self.root.after(1000, self.update_graph_label)
        if self.current_graph_label != self.new_graph_label and self.new_graph_label is not None:
            self.current_graph_in_use = selected_graph_value
            self.adjusting_graph('Neutral')
        self.current_graph_label = selected_graph_value
        self.new_graph_label = selected_graph_value

    def create_time_dropdown(self):
        self.time_dropdown_title = tk.Label(self.frame, text='Graph Based on Time')
        self.time_dropdown_title.grid(row=0, column=0)
        self.selected_time_value = tk.StringVar()
        time_options = ['Year', 'Quarter', 'Month', 'Week', 'Day']
        dropdown_time_menu = tk.OptionMenu(self.frame, self.selected_time_value, *time_options)
        dropdown_time_menu.grid(row=1, column=0)
        self.selected_time_value.set(self.time_frame.title())
        self.time_label = tk.Label(self.frame, text='Time')
        self.time_label.grid(row=2, column=0)
        self.update_time_label()

    def update_time_label(self):
        selected_time_value = self.selected_time_value.get()
        self.time_label.config(text= f'Selected Time Period: {selected_time_value}')
        self.current_time_label = selected_time_value
        self.root.after(1000, self.update_time_label)
        if self.current_time_label != self.new_time_label and self.new_time_label is not None:
            self.time_frame = selected_time_value
            self.adjusting_graph('Neutral')
        self.current_time_label = selected_time_value
        self.new_time_label = selected_time_value

    def create_descriptor_dropdown(self):
        dropdown_descriptor_window = tk.Label(self.frame, text='Category')
        dropdown_descriptor_window.grid(row=0, column=1)
        self.selected_descriptor_value = tk.StringVar()
        descriptor_options = ["Category", "Brand", 'Color', 'Size', 'Condition'] #Time to sale but binned in groups of 10?

        dropdown_descriptor_menu = tk.OptionMenu(self.frame, self.selected_descriptor_value, *descriptor_options)
        dropdown_descriptor_menu.grid(row=1, column=1)

        self.selected_descriptor_value.set(self.graph_descriptor)
        self.descriptor_label = tk.Label(self.frame, text='')
        self.descriptor_label.grid(row=2, column=1)
        self.update_descriptor_label()

    def update_descriptor_label(self):
        selected_descriptor_value = self.selected_descriptor_value.get()
        self.descriptor_label.config(text= 'Selected Category : ' + selected_descriptor_value)
        self.current_descriptor_label = selected_descriptor_value
        self.root.after(1000, self.update_descriptor_label)

        if self.current_descriptor_label != self.new_descriptor_label and self.new_descriptor_label is not None:
            self.graph_descriptor = selected_descriptor_value
            self.adjusting_graph('Neutral')
        self.current_descriptor_label = selected_descriptor_value
        self.new_descriptor_label = selected_descriptor_value

    def create_overall_stats_dropdown(self):
        overall_stats_dropdown = tk.Label(self.frame, text='Overall Stats')
        overall_stats_dropdown.grid(row=0, column=3)
        self.overall_solds_label = tk.Label(self.frame,text='')
        self.overall_solds_label.grid(row=1, column=3)

        self.overall_revenue_label = tk.Label(self.frame, text='')
        self.overall_revenue_label.grid(row=2, column=3)
        self.overall_stats()

    def overall_stats(self):
        self.total_revenue = self.database_in_use['Total after fees'].sum()
        self.total_num_of_solds = len(self.database_in_use)
        self.overall_solds_label.config(text=f'Total Number of Solds {self.total_num_of_solds}')
        self.overall_revenue_label.config(text=f'Total Revenue ${self.total_revenue.round(2)}')
        #! add a percentage based on platform sales
        self.root.after(1000, self.overall_stats)

    def threading_information_filter_loop(self, total_row_text, threading_key, reverse_bool=False):
        """
        method we use to sort threading information to place in text area scrollbar
        """
        for text in sorted(total_row_text, key=threading_key, reverse=reverse_bool):
            for i in range(1,13):
                self.text_area.insert(tk.END, text[i])
                self.text_area.insert(tk.END, '\n')
            self.text_area.insert(tk.END, '\n\n')
        self.text_area.update()

    def threading_information_program_loop(self, total_row_text, selected_program):
        """
        just like threading_information_filter_loop method above but to filter by program, not the filter
        """
        for text in sorted(total_row_text):
            if selected_program != 'All':
                if selected_program in text[10]:
                    for i in range(1,13):
                        self.text_area.insert(tk.END, text[i])
                        self.text_area.insert(tk.END, '\n')
            else:
                for i in range(1,13):
                    self.text_area.insert(tk.END, text[i])
                    self.text_area.insert(tk.END, '\n')
            self.text_area.insert(tk.END, '\n\n')
        self.text_area.update()

    def threading_information_method(self, sorting_method, update_label_method):
        """
        method used to speed up the process information method
        """
        #! figure out way to incorporate database_we_are_using, currently malfunctioning and not displaying proper current values
        self.delete_text_area()
        total_row_text = []
        self.get_image_list = []
        self.actual_images_list = []

        total_db_rows = len(self.database_we_are_using)
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = [executor.submit(self.process_item_information, index, row, total_row_text) for index, row in self.database_we_are_using.iterrows()]
            concurrent.futures.wait(futures)

        if update_label_method == 'Filter':
            if sorting_method == 'Nearest Sold':
                key_function = lambda x: x[0]
                reverse_bool = False
            elif sorting_method == 'Farthest Sold':
                key_function = lambda x: x[0]
                reverse_bool = True
            elif sorting_method == 'Highest to Lowest Price':
                key_function = lambda x: float(x[3].replace('Sold Price: ', ''))
                reverse_bool = False
            elif sorting_method == 'Lowest to Highest Price':
                key_function = lambda x: float(x[3].replace('Sold Price: ', ''))
                reverse_bool = True
            elif sorting_method == 'Sold Quickest':
                #! some dates are off so figure out why this is off by a bit?!?!?!
                #! maybe make if = 0 make it unknown and put it at the end?? maybe give it a day like 99999
                #! Also figure out why dates are +- 1
                key_function = lambda x: int(x[12].replace('Time to Sale: ', '').replace(" Days", '').strip()) if x[12].replace('Time to Sale: ', '').replace(" Days", '').strip().isdigit() else 99999
                reverse_bool = False
            elif sorting_method == 'Sold Longest':
                key_function = lambda x: int(x[12].replace('Time to Sale: ', '').replace(" Days", '').strip()) if x[12].replace('Time to Sale: ', '').replace(" Days", '').strip().isdigit() else 99999
                reverse_bool = True
            print('yeah baby')
            self.threading_information_filter_loop(total_row_text, key_function, reverse_bool)

        elif update_label_method == 'Program':
            #! maybe find some way to include other factors, like if they are only 1 other program, vs the whole package for all programs
            if sorting_method in ['All', 'Depop', 'Ebay', 'Grailed', 'Facebook Marketplace', 'Offer Up']:
                selected_program = sorting_method
            self.threading_information_program_loop(total_row_text, selected_program)


        #! LAZY LOADING?
        #! find some way to create it so that it will load text first, then insert pictures when it sees fit, but for that just have to create a simple formula to insert pictures into the correct area, because the issue isnt really 

        method_start = time.time()
        self.iteration_counter = 0
        self.image_url_counter = 0
        with concurrent.futures.ThreadPoolExecutor() as executor:
            print('starting 2nd threading')
            image_futures = [executor.submit(self.image_url_threader, img_id, img) for img_id, img in enumerate(self.get_image_list)]
            concurrent.futures.wait(image_futures)

        method_end = time.time()
        iterations_per_second = self.iteration_counter / (method_end - method_start)
        print(f'Total End Time is {round((method_end - method_start), 2)} for {total_db_rows} Posts')
        print(round(((method_end - method_start)/total_db_rows), 2), 'Seconds Per Post')
        print(f"Total Iterations {self.iteration_counter}")
        print(f'Iterations Per Second {round(iterations_per_second, 2)}')

#! good thing to run deep nerual network on to find out how to maximize its efficiency
        #TODO issue where it gets stuck on 1 picutre sometimes and cant load rest of pictures
    def image_url_threader(self, img_id, img):
        if img != 'Nothing':
            image = self.get_image('url', img)
        else:
            image = self.get_image('file', r"D:\Selenium_python2\DefaultNoPictureItem.jpg")
        while self.image_url_counter != img_id:
            self.iteration_counter += 1
            time.sleep(max(0.22, min(3, (img_id - self.image_url_counter) / 10)))

        self.display_image(image, img_id)
        self.image_url_counter += 1

    def process_item_information(self, index, row, total_row_text):
        """
        processes each row series to list as text in the tkinter window we just opened
        """
        try:
            selected_columns = ['Description', 'Total after fees', 'Condition', 'Brand', 'Category', 'Color', 'Size', 'Likes', 'Program', "Date of sale", 'time_to_sale']
            selected_values = [str(row[column]) for column in selected_columns]
            columns_for_text = ['Title', 'Sold Price', 'Condition', 'Brand', 'Category', 'Color', 'Size', 'Likes', 'Program', "Date of sale", 'Time to Sale']

            des_value = selected_values[0]
            price_value = selected_values[1]
            cond_value = selected_values[2]
            brand_value = selected_values[3]
            category_value = selected_values[4]
            color_value = selected_values[5]
            size_value = selected_values[6]
            likes_value = selected_values[7]
            program_value = selected_values[8]
            date_sale_value = selected_values[9]
            time_sale_value = selected_values[10].replace('00:00:00', '').title()
            try:
                image_url = row['Images'].split('; ')[0]
                self.get_image_list.append(image_url)
            except:
                self.get_image_list.append('Nothing')

            # try: #! TURN THIS ON; this is to add pictures into text_area, just nee dto figure out a way to make thos process faster, threading?
            #     image_url = row['Images'].split('; ')[0]
            #     if image_url:
            #         image = self.get_image('url', image_url)
            # except AttributeError:
            #     image = self.get_image('file', r"D:\Selenium_python2\DefaultNoPictureItem.jpg")
            # row_text = ((index + 1), image, f"Row {index + 1}: {', '.join(selected_values)}\n\n")
            #TODO Can make this easier
            row_text = (
                (index + 1),
                f"Row {index + 1}:",
                f'{columns_for_text[0]}: {des_value}',
                f'{columns_for_text[1]}: {price_value}',
                f'{columns_for_text[2]}: {cond_value}',
                f'{columns_for_text[3]}: {brand_value}',
                f'{columns_for_text[4]}: {category_value}',
                f'{columns_for_text[5]}: {color_value}',
                f'{columns_for_text[6]}: {size_value}',
                f'{columns_for_text[7]}: {likes_value}',
                f'{columns_for_text[8]}: {program_value}',
                f'{columns_for_text[9]}: {date_sale_value}',
                f'{columns_for_text[10]}: {time_sale_value}',
                '\n'
            )
            total_row_text.append(row_text)
        except Exception as e:
            self.handle_exception(e, 'process_item_information')

#!!! this is a way where we can see the aggregates of each bar, just by hovering over it no matter the x value
    def on_hover(self, sel, database_in_use, descriptor_used, type_of_graph):
        """
        sel refers to the information from the selection object
        detects which bar we are hovering over, and proceed to return the aggregates for that bar
        """
        xticklabels = [label.get_text() for label in plt.gca().get_xticklabels()]
        xdata = sel.target[0] + 0.5
        bar_name = xticklabels[int(xdata)]
        if type_of_graph == 'date':
            descriptor_used = 'year_month'
        filtered_data = database_in_use[database_in_use[descriptor_used] == bar_name]
        for _, row in filtered_data.iterrows():
            desired_avg = row['sales_for_mean']
            desired_sum = row['sales_for_sum']
            desired_size = row['sales_for_size']
            desired_max = row['sales_for_max']
            desired_time_avg = int(row['time_sales_for_avg'])
        #! need to add type of agg, or the y value and its agg that we use to filter
            #! the way we'd be able to tell the amount of programs is whether or not they are T or F in the database
            #? or should i do it based on what programs are in the information given to me?
            #? is it important to put a 0 where no sales for that program? yes it is, I only have so much space though, it would kinda be implied, but who knows some wouldnt be able to imply, so its there for them to see
        # programs_that_are_true = ['Depop', 'Ebay']
        program_text = ''
        for programs in self.program_total_name_list:
            program_row_info = row[f'{programs}_sales_sum']
            revenue_from_programs = f'{programs} Total Sales: {program_row_info}\n'
            program_text += revenue_from_programs

        text = f"""
            {bar_name}
            Mean: {desired_avg}
            Sum: {desired_sum}
            Total Sold This Month: {desired_size}
            Most Expensive Item Sold: {desired_max}
            Average Time Items Took to Sell: {desired_time_avg}
            {program_text}
        """
        sel.annotation.set_text(text)
        sel.annotation.set_bbox(dict(boxstyle='round', fc='gray')) #TODO find a way to set horizontal alignment to left?? not an immediate issue at this moment

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    #! this is what we use to put all the graph information together and create our graphs using the information we have prepared above
    def program_pie_chart(self, first):
        """
        Visualize total percentage based on program, get overall sensus of what program is better
        
        Plan to one day utilize this to get a better idea of using it with like category, maybe not those, maybe just with this since theres not too many options, so wont be too cluttered
        """
        if first == True:
            self.pie_fig = plt.figure()
            self.pie_ax = self.pie_fig.add_subplot(111)
        else:
            self.pie_ax.clear()
        program_data = self.database_in_use['Program']
        program_value_counts = program_data.value_counts()
        color_dict = {
            'Depop': '#c20c0c',
            'Ebay': '#fbe752',
            'Grailed': 'gray',
            'Facebook Marketplace': 'royalblue',
            'OfferUp': 'olivedrab',
            'Etsy': 'orange'
        }
        colors = [color_dict.get(label, 'black') for label in program_value_counts.index]

        self.pie_ax.pie(program_value_counts, labels=program_value_counts.index, colors=colors, autopct='%1.1f%%', startangle=90)
        self.pie_ax.set_title('Percentage Based on Program')
        self.pie_fig.canvas.draw()

    def graph_adjustors(self, x_label, y_label, title, plot_chart, plot_aggregate, database_in_use, descriptor_used, type_of_graph, first, og_database_in_use=None, max_x_values=60):
        """ 
        this is the actual function of putting something into the graph, the information that goes into the plot
        """
        global max_value
        plt.ion()
        if first == True:
            self.fig = plt.figure(figsize=(12, 6))
            self.ax = self.fig.add_subplot(111)
        plt.xlabel(x_label)
        plt.ylabel(y_label)
        plt.title(title)
        plt.gca().spines['right'].set_visible(False)
        plt.gca().spines['top'].set_visible(False)
        # self.fig.set_facecolor('darkgray')
        # plt.gca().set_facecolor('darkgray')
        if not plot_chart.empty:
            plt.subplots_adjust(bottom=0.3, right=0.95, left=0.05)
            plot_chart_subset = plot_chart[:max_x_values].astype(str)
            plot_aggregate_subset = plot_aggregate[:max_x_values].astype(int)
            max_value = max(plot_aggregate_subset)
            colors = [self.value_to_color(value) for value in plot_aggregate_subset]
            self.bars = plt.bar(plot_chart_subset, plot_aggregate_subset, label='Bar Chart', color=colors, alpha=0.7, picker=5)
            print(plot_chart_subset, plot_chart_subset.tolist())
            plt.xticks(plot_chart_subset, plot_chart_subset.tolist(), rotation='vertical', fontsize=6)
            for i, y in enumerate(plot_aggregate_subset):
                plt.text(i, y, str(y), ha='center', va='bottom', fontsize=8, fontweight='bold')
        self.annotation = self.ax.annotate(
            text=' ',
            xy=(0,0),
            bbox={'boxstyle': 'round', 'fc': 'gray'},
            ha='left'
            )
        self.database_in_use = og_database_in_use
        database_for_hover = database_in_use
        self.fig.canvas.mpl_connect('pick_event', partial(self.on_bar_click, descriptor_used=descriptor_used, type_of_graph=type_of_graph))
        mplcursors.cursor(hover=True).connect('add', lambda event: self.on_hover(event, database_in_use=database_for_hover, descriptor_used=descriptor_used, type_of_graph=type_of_graph))
        self.annotation.set_visible(False)
        plt.tight_layout()
        plt.draw()
        self.program_pie_chart(first)
        plt.sca(self.ax)
        self.root.geometry("800x400")
        threading.Thread(target=self.iterate_through_graph_info, args=(None, type_of_graph)).start()
        # self.db.to_csv('Store_Sales.xlsx', index=False)

    def run(self):
        self.root.mainloop()

DATABASE_PATH = r"/Users/argelarroyo/Documents/MyEmployee/Depop_database.db"
ACCOUNT_USERNAME = '_realvintage'

#! maybe an option to change the aggregate? alter the table the same way i did for the arrow?
#! create a dropdown module similar to the one for text area i made, but interacting with the graph and not the text area

#! create dropdown object to chooese from for this
if __name__ == "__main__":
    time_frame = 'quarter'
    time_slot = 4
    time_year = 2023
    graph_descriptor = 'Brand'
    graph_agg = 'size'
    graph_program = 'All'
    stats_instance = StatsVisualizer(DATABASE_PATH, ACCOUNT_USERNAME, time_slot, time_frame, time_year, graph_descriptor, graph_agg, graph_program)
    #! figure out what we need brand for
    """
    This code works great other than figuring out what we need brand for in terms of an argument
    """

    #! have already been checked and work congruently with no bugs
    # stats_instance.graph_date_creator()
    # stats_instance.graphing()
    # stats_instance.average_time_to_sell()
    stats_instance.graphing(True)
    # stats_instance.quickest_sales()
    stats_instance.run()

"""
- make universal sold to filter out all solds from active databases
"""

#! on bar click works but for some reason i have to wait a second to use it, so i need to figure that out
#! maybe can even make a type of graph for graph date creator where it tracks the sale of one specific descriptor/column, like Nike, or Jackets?
""" 
Ive done everything I am planning on doing with this, the only thing i have left to do now is to make sure it all runs smoothly...
on_bar_click works with all graphs
text_area works for all graphs and all possible variations, whether its with using dropdown menu, etc
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
How would I use this/ Market this out?
since my gui isnt ready, maybe i can offer to do visualizations for people, get their data, run it through my program, then after it is all completed, maybe create a mini gui program where they can run through these filters themselves so they can customize it to their chosing?
just like a little page/app they can open where all of this will be at their fingertips whenever they choose to open it

Step 1: Figure out my possible customers; top sellers and ppl with over 100 sales
Create a program to get all the top sellers, or sellers with lots of sales, over 100 in depop to send a message to offering my service
Create a good script, maybe reel them in with a question rather than just get straight into it, something like...
"Hey, I love what's on your page and you seem like you've been doing great on *Said Program*.  Have you ever had your stats analyzed for you?"

something like that, ofc build off that but that is a good basis for me, just something to reel them in, and not sound like a lousy salesman, but more liek someone that is offering them a cheap and affordable service they can utilize to maximize their saling potential

figure out what to do with sales that are scraped from depop website, not scraped with excel.  WIth this then I will be able to have thousands of sales to refer back to, and even offer that as a service, create 2 different graphs, 
one 1 more accurate information but less solds
the other with a ton more solds, literally thousands, but much less accurate specific sales, but will still  be able to tell what is selling, category, title, color, etc, just not the price       
"""

#! for likes, replace nan w/ None
#! create a function to find the profit made,
""" 
considering that to find the profit, we need to find the revenue, and at least for me is not applicable, so what we can do is fill in what we do know, this would have to be involving the data of the specific individual,
get the average price of what he buys for depending on the item; shoes, shirt, jackets etc, then just get the average of that then place that as the revenue
"""

#! option to make it so that if i click the outer part of the bar, where there are no bars, 
#! it'll go back to default, or maybe just create a button to make it reset back to normal

##############################################
#final to do list
""" 
- Create arrows to shift to next time periods
       for this maybe create like a dictionary/list, but for this would somehow need to add year into this too, because i dont want it to stay on the same year
- Create GUI page to put all these into one page and make it easier for people to run the program
"""

#TODO TODO LIST
""" 
- Set a limit so you cant just go to like year 2050, just the first month and last month of your sale, min and max
- Fix issue with slow displaying image, or maybe just include that in advanced statistics package
- Make sure this data will scrape sold data nicely
"""
